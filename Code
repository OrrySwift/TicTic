//only destroy enemies that go off the side of the screen

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

using System.Media;

namespace TicTic
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            g = CreateGraphics();
            t = new Timer();
            t.Interval = 16;
            t.Tick += new EventHandler(timer_tick);
            t.Start();
            CurrentTick = 0;
            r = new Random();
            playerLocation = new PointF(300, 500);
            playerAnimation = 0;
            wDown = false;
            aDown = false;
            sDown = false;
            dDown = false;
            spaceDown = false;
            shiftDown = false;
            allBullets = new Bullet[0];
            allEnemys = new Enemy[0];
            playerLives = 5;
            distance = 0;
            playerFire.Load();
            WorldSection = 0;
            for (int i = 0; i < WorldString.Length; i++)
            {
                if (WorldString[i] == ';')
                {
                    WorldSection++;
                }
            }
            World = new int[WorldSection, 3];
            int start = 0;
            int end = 0;
            WorldSection = 0;
            int SectionSection = 0;
            for (int i = 0; i < WorldString.Length; i++ )
            {
                if (WorldString[i] == ';' || WorldString[i] == ',')
                {
                    end = i - 1;
                    if (SectionSection == 2 && WorldSection != 0)
                    {
                        World[WorldSection, 2] = Convert.ToInt32(WorldString.Substring(start, end - start));
                        World[WorldSection, 2] += World[WorldSection - 1, 2];
                    }
                    else
                    {
                        World[WorldSection, SectionSection] = Convert.ToInt32(WorldString.Substring(start, end - start));
                    }
                    SectionSection++;
                    if (SectionSection == 3)
                    {
                        SectionSection = 0;
                        WorldSection++;
                    }
                    start = i + 1;
                }
            }
            WorldSection = 0;
            PlayWindow = new Rectangle(this.Width/2-300, this.Height/2-300, 600,600);
            BossAlive = false;
        }

        const string WorldString = @"0,0,10;1,0,5;";
        int[,] World; //X,Y   Y=0, enemy type  Y=1, enemy AI   Y=2, Distance to go the next worldsection
        int WorldSection;
        Timer t;
        Graphics g;
        Pen p = new Pen(Color.White, 1f);
        int CurrentTick;
        Random r;
        PointF playerLocation;
        const float playerSpeed = 4f;
        const float playerDSpeed = 2.828f;
        Size playerSize = new Size(20, 20);
        int playerLives;
        int playerAnimation;
        bool wDown;
        bool aDown;
        bool sDown;
        bool dDown;
        bool spaceDown;
        bool shiftDown;
        Bullet[] allBullets;
        Enemy[] allEnemys;
        int distance;
        Rectangle PlayWindow;
        bool BossAlive;

        Image player = Image.FromFile(@"H:\Projects\Forms\bul\Player.PNG");
        Image bulletIMG = Image.FromFile(@"H:\Projects\Forms\bul\Bullets.PNG");
        Image enemyIMG = Image.FromFile(@"H:\Projects\Forms\bul\Enemy.PNG");

        SoundPlayer playerFire = new SoundPlayer(@"H:\Projects\Forms\bul\PlayerFire.WAV");

        public class Bullet
        {
            public PointF Location;
            public PointF Velocity;
            public Size bSize;
            public bool HurtPlayer;
            public int bImage;
            public bool destroy;
            public Bullet(PointF XLocation = new PointF(), PointF XVelocity = new PointF(), Size xSize = new Size(), bool XHurtPlayer = true, int xImage = 0)
            {
                Location = XLocation;
                Velocity = XVelocity;
                bSize = xSize;
                HurtPlayer = XHurtPlayer;
                bImage = xImage;
                destroy = false;
            }
        }

        public class Enemy
        {
            public PointF Location;
            public Size bSize;
            public int MovePattern;
            public int MovePatternPoint;
            public int bImage;
            public bool destroy;
            public int HP;
            public int maxHP;

            public Enemy(PointF XLocation = new PointF(), Size xSize = new Size(), int XMovePattern = 0, int xImage = 0, int xmaxHP = 1)
            {
                Location = XLocation;
                bSize = xSize;
                MovePattern = XMovePattern;
                MovePatternPoint = 0;
                bImage = xImage;
                destroy = false;
                maxHP = xmaxHP;
                HP = maxHP;
            }
        }

        private Size EnemyTypeSize(int EnemyImage)
        {
            Size output = new Size(0, 0);
            switch (EnemyImage)
            {
                case 0:
                    output.Width = 25;
                    output.Height = 25;
                    break;
                case 1:
                    output.Width = 13;
                    output.Height = 19;
                    break;
            }
            return output;
        }

        private PointF MovePatternStartLocation(int MovePattern)
        {

            PointF output = new PointF(0, 0);
            switch (MovePattern)
            {
                case 0:
                    output.X = 300;
                    output.Y = 100;
                    break;
                case 1:
                    output.X = 13;
                    output.Y = 19;
                    break;
            }
            return output;
        }

        private string MovePatternInfo(string ReturnType, int MovePattern)
        {
            //start location
            //maxHP
            //isBoss
            //
            return "";
        }

        private PointF MovePatternNext(int MovePattern, ref int MovePatternPoint)
        {
            PointF output = new PointF(0f, 0f);

            switch (MovePattern)
            {
                case 0:
                    switch (MovePatternPoint)
                    {
                        case 0: output.X = 0f; output.Y = 0f; break;
                        case 1: MovePatternPoint = 0; output.X = 0f; output.Y = 0f; break;
                    }
                    break;
                case 1:
                    switch (MovePatternPoint)
                    {
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10: output.X = 0f; output.Y = 0.5f; break;
                        case 11: output.X = 0f; output.Y = 0f; break;
                        case 12: output.X = 0f; output.Y = 0f; break;
                        case 13: output.X = 0f; output.Y = 0f; break;
                        case 14: output.X = 0f; output.Y = 0f; break;
                        case 15: MovePatternPoint = 0; output.X = 0f; output.Y = 0f; break;
                    }
                    break;
                    break;
                case 2:

                    break;

            }
            return output;
        }

        private void timer_tick(object sender, EventArgs e)
        {
            if (playerLives == 0)
            {
                this.Close();
            }

            CurrentTick++;
            PointF playerLocChange = new PointF(0f, 0f);
            if (wDown)
            {
                playerLocChange.Y -= playerSpeed;
            }
            if (aDown)
            {
                playerLocChange.X -= playerSpeed;
            }
            if (sDown)
            {
                playerLocChange.Y += playerSpeed;
            }
            if (dDown)
            {
                playerLocChange.X += playerSpeed;
            }
            if (playerLocChange.X != 0 && playerLocChange.Y != 0)
            {
                int temp = Convert.ToInt32(playerLocChange.X / playerSpeed);
                switch (temp)
                {
                    case -1:
                        playerLocChange.X = -playerDSpeed;
                        break;
                    case 1:
                        playerLocChange.X = playerDSpeed;
                        break;
                }
                temp = Convert.ToInt32(playerLocChange.Y / playerSpeed);
                switch (temp)
                {
                    case -1:
                        playerLocChange.Y = -playerDSpeed;
                        break;
                    case 1:
                        playerLocChange.Y = playerDSpeed;
                        break;
                }

            }
            if (shiftDown)
            {
                playerLocChange.X = playerLocChange.X / 2;
                playerLocChange.Y = playerLocChange.Y / 2;
            }
            playerLocation.X += playerLocChange.X;
            playerLocation.Y += playerLocChange.Y;



            if (playerLocation.X < 0)
            {
                playerLocation.X = 0;
            }
            if (playerLocation.X > this.Width - playerSize.Width * 2)
            {
                playerLocation.X = this.Width - playerSize.Width * 2;
            }
            if (playerLocation.Y < 0)
            {
                playerLocation.Y = 0;
            }
            if (playerLocation.Y > this.Height - playerSize.Height * 2)
            {
                playerLocation.Y = this.Height - playerSize.Height * 2;
            }


            if (wDown || aDown || sDown || dDown)
            {
                playerAnimation = 0;
            }
            else
            {
                playerAnimation++;
                if (playerAnimation == 3)
                {
                    playerAnimation = 0;
                }
            }

            int remainingBullets = 0;
            for (int i = 0; i < allBullets.Length; i++)
            {
                remainingBullets++;
                allBullets[i].Location.X += allBullets[i].Velocity.X;
                allBullets[i].Location.Y += allBullets[i].Velocity.Y;
                if (allBullets[i].Location.X < -allBullets[i].bSize.Width * 2)
                {
                    allBullets[i].destroy = true;
                    remainingBullets--;
                }
                else if (allBullets[i].Location.X > this.Width)
                {
                    allBullets[i].destroy = true;
                    remainingBullets--;
                }
                else if (allBullets[i].Location.Y < -allBullets[i].bSize.Height * 2)
                {
                    allBullets[i].destroy = true;
                    remainingBullets--;
                }
                else if (allBullets[i].Location.Y > this.Height)
                {
                    allBullets[i].destroy = true;
                    remainingBullets--;
                }
            }

            if (remainingBullets != allBullets.Length)
            {
                Bullet[] tempBullets = new Bullet[remainingBullets];
                int currentTemp = 0;
                for (int i = 0; i < allBullets.Length; i++)
                {
                    if (!allBullets[i].destroy)
                    {
                        tempBullets[currentTemp] = allBullets[i];
                        currentTemp++;
                    }
                }
                allBullets = tempBullets;
            }



            if (CurrentTick % 8 == 0)
            {
                if (spaceDown)
                {
                    Bullet[] newPBullet = new Bullet[allBullets.Length + 1];
                    for (int i = 0; i < allBullets.Length; i++)
                    {
                        newPBullet[i] = allBullets[i];
                    }
                    newPBullet[newPBullet.Length - 1] = new Bullet(new PointF(playerLocation.X + playerSize.Width - 3, playerLocation.Y), new PointF(0f, -4.5f), new Size(3, 3), false, 0);
                    allBullets = newPBullet;
                    playerFire.Play();
                }

            }
            if (CurrentTick % 30 == 0)
            {
                if (!BossAlive)
                {
                    distance++;
                    if (World[WorldSection, 0] != 0)
                    {
                        Enemy[] newEnemy = new Enemy[allEnemys.Length + 1];
                        for (int i = 0; i < allEnemys.Length; i++)
                        {
                            newEnemy[i] = allEnemys[i];
                        }
                //        newEnemy[newEnemy.Length - 1] = new Enemy(new PointF(playerLocation.X + playerSize.Width - 3, playerLocation.Y), new PointF(0f, -4.5f), new Size(3, 3), false, 0);
                        allEnemys = newEnemy;
                    }



                    if (World[WorldSection, 2] == distance)
                    {
                        WorldSection++;
                    }
                }
            }

            if (CurrentTick % (30 * 8) == 0)
            {
                CurrentTick = 0;
            }


            Refresh();
        }

        private void Form1_Paint(object sender, PaintEventArgs e)
        {
            PlayWindow = new Rectangle(this.Width / 2 - 300, this.Height / 2 - 300, 600, 600);
            e.Graphics.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.NearestNeighbor;
            g = e.Graphics;

            g.Clear(Color.Black);
            //background



            //bullets
            for (int i = 0; i < allBullets.Length; i++)
            {
                g.DrawImage(bulletIMG, new Rectangle(PlayWindow.X + Convert.ToInt32(Math.Floor(allBullets[i].Location.X)), PlayWindow.Y + Convert.ToInt32(Math.Floor(allBullets[i].Location.Y)), allBullets[i].bSize.Width * 2, allBullets[i].bSize.Height * 2), new Rectangle(allBullets[i].bImage * 15, 0, allBullets[i].bSize.Width, allBullets[i].bSize.Height), GraphicsUnit.Pixel);

            }


            //enemies

            for (int i = 0; i < allEnemys.Length; i++)
            {
                g.DrawImage(enemyIMG, new Rectangle(PlayWindow.X + Convert.ToInt32(Math.Floor(allEnemys[i].Location.X)), PlayWindow.Y + Convert.ToInt32(Math.Floor(allEnemys[i].Location.Y)), allEnemys[i].bSize.Width * 2, allEnemys[i].bSize.Height * 2), new Rectangle(0, 0, 3, 3), GraphicsUnit.Pixel);

            }



            //player
            g.DrawImage(player, new Rectangle(PlayWindow.X + Convert.ToInt32(Math.Floor(playerLocation.X)), PlayWindow.Y + Convert.ToInt32(Math.Floor(playerLocation.Y)), playerSize.Width * 2, playerSize.Height * 2), new Rectangle(20 * playerAnimation, 0, 20, 20), GraphicsUnit.Pixel);



        }

        private void Form1_KeyDown(object sender, KeyEventArgs e)
        {
            switch (e.KeyCode)
            {
                case Keys.W:
                    wDown = true;
                    break;
                case Keys.A:
                    aDown = true;
                    break;
                case Keys.S:
                    sDown = true;
                    break;
                case Keys.D:
                    dDown = true;
                    break;
                case Keys.Space:
                    spaceDown = true;
                    break;
                case Keys.Shift:
                    shiftDown = true;
                    break;
            }
        }

        private void Form1_KeyUp(object sender, KeyEventArgs e)
        {
            switch (e.KeyCode)
            {
                case Keys.W:
                    wDown = false;
                    break;
                case Keys.A:
                    aDown = false;
                    break;
                case Keys.S:
                    sDown = false;
                    break;
                case Keys.D:
                    dDown = false;
                    break;
                case Keys.Space:
                    spaceDown = false;
                    break;
                case Keys.Shift:
                    shiftDown = false;
                    break;
            }
        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }
    }
}
